import axios from 'axios';
import * as cheerio from 'cheerio';
import { BaseIngestionWorker, type SourceConfig, type WorkerType } from '../lib/worker-interface';
import type { RawMix, RawTrack } from '../lib/supabase/types';
import { createExternalId } from '../lib/external-ids';
import { logger } from '../services/logger';
import { BasicContextRulesEngine, type ContextSuggestion, type MixContent } from '../lib/context-rules-engine';

/**
 * SoundCloud ingestion worker
 * Fetches mixes from SoundCloud artists/labels and parses tracklists from descriptions
 */
export class SoundCloudWorker extends BaseIngestionWorker {
  readonly workerType: WorkerType = 'soundcloud';
  readonly name = 'SoundCloud Worker';
  
  private clientId?: string;
  private userAgent = 'mixd-ingestion/1.0';
  private contextRulesEngine: BasicContextRulesEngine;
  
  constructor() {
    super();
    this.clientId = process.env.SOUNDCLOUD_CLIENT_ID;
    this.contextRulesEngine = new BasicContextRulesEngine();
    
    if (!this.clientId) {
      logger.warn('SOUNDCLOUD_CLIENT_ID not set, will attempt to extract from web player');
    }
  }
  
  /**
   * Fetch new mixes from SoundCloud artists/labels
   */
  async fetchNewMixes(config: SourceConfig): Promise<RawMix[]> {
    const { artists = [], labels = [], maxResults = 50, dateRange } = config;
    const allSources = [...artists, ...labels];
    
    if (allSources.length === 0) {
      logger.warn('No SoundCloud artists or labels configured');
      return [];
    }
    
    const rawMixes: RawMix[] = [];
    
    for (const source of allSources) {
      try {
        logger.info(`Fetching tracks from SoundCloud user: ${source}`);
        const tracks = await this.fetchUserTracks(source, maxResults, dateRange);
        rawMixes.push(...tracks);
      } catch (err) {
        logger.error(`Failed to fetch tracks from ${source}`, err as Error, {
          workerType: this.workerType,
        });
      }
    }
    
    return rawMixes;
  }
  
  /**
   * Parse tracklist from SoundCloud description
   */
  async parseTracklist(rawMix: RawMix): Promise<RawTrack[] | null> {
    if (!rawMix.raw_description) {
      return null;
    }
    
    logger.debug(`Parsing tracklist for: ${rawMix.raw_title}`);
    
    const tracks: RawTrack[] = [];
    const lines = rawMix.raw_description.split('\n');
    let position = 1;
    
    for (const line of lines) {
      const trimmedLine = line.trim();
      if (this.isTrackLine(trimmedLine)) {
        const parsedTrack = this.parseTrackLine(trimmedLine, position);
        if (parsedTrack) {
          tracks.push({
            id: '', // Will be generated by database
            raw_mix_id: rawMix.id,
            line_text: trimmedLine,
            position,
            timestamp_seconds: parsedTrack.timestamp ?? null,
            raw_artist: parsedTrack.artist ?? null,
            raw_title: parsedTrack.title ?? null,
            source: 'description',
            created_at: new Date().toISOString(),
          });
          position++;
        }
      }
    }
    
    logger.info(`Parsed ${tracks.length} tracks from SoundCloud description`);
    return tracks.length > 0 ? tracks : null;
  }
  
  /**
   * Fetch tracks from a SoundCloud user
   */
  private async fetchUserTracks(
    username: string,
    limit: number,
    dateRange?: { from?: Date; to?: Date }
  ): Promise<RawMix[]> {
    try {
      // Try API approach first if we have client ID
      if (this.clientId) {
        return await this.fetchViaAPI(username, limit, dateRange);
      }
      
      // Fallback to web scraping
      return await this.fetchViaWebScraping(username, limit, dateRange);
    } catch (err) {
      logger.error(`Failed to fetch user tracks for ${username}`, err as Error);
      return [];
    }
  }
  
  /**
   * Fetch tracks via SoundCloud API (if client ID available)
   */
  private async fetchViaAPI(
    username: string,
    limit: number,
    dateRange?: { from?: Date; to?: Date }
  ): Promise<RawMix[]> {
    // First resolve username to user ID
    const userResponse = await axios.get(`https://api.soundcloud.com/resolve`, {
      params: {
        url: `https://soundcloud.com/${username}`,
        client_id: this.clientId,
      },
      headers: {
        'User-Agent': this.userAgent,
      },
    });
    
    const userId = userResponse.data.id;
    
    // Fetch user's tracks
    const tracksResponse = await axios.get(`https://api.soundcloud.com/users/${userId}/tracks`, {
      params: {
        client_id: this.clientId,
        limit,
        linked_partitioning: 1,
      },
      headers: {
        'User-Agent': this.userAgent,
      },
    });
    
    const tracks = tracksResponse.data.collection || [];
    
    const filteredTracks = tracks.filter((track: any) => this.isValidMix(track, dateRange));
    return Promise.all(filteredTracks.map((track: any) => this.mapAPITrackToRawMix(track)));
  }
  
  /**
   * Fetch tracks via web scraping (enhanced fallback method)
   */
  private async fetchViaWebScraping(
    username: string,
    limit: number,
    dateRange?: { from?: Date; to?: Date }
  ): Promise<RawMix[]> {
    try {
      const url = `https://soundcloud.com/${username}/tracks`;
      
      // Try direct HTTP request first
      let $ = await this.fetchPageWithAxios(url);
      let tracks = await this.extractTracksFromHTML($, username, limit);
      
      // If we didn't get enough tracks, try with browser automation
      if (tracks.length === 0) {
        logger.info(`No tracks found with HTTP request for ${username}, trying browser automation`);
        $ = await this.fetchPageWithBrowser(url);
        tracks = await this.extractTracksFromHTML($, username, limit);
      }
      
      // Filter by date range if specified
      if (dateRange) {
        tracks = tracks.filter(track => {
          if (!track.uploaded_at) return true;
          const uploadDate = new Date(track.uploaded_at);
          if (dateRange.from && uploadDate < dateRange.from) return false;
          if (dateRange.to && uploadDate > dateRange.to) return false;
          return true;
        });
      }
      
      logger.info(`Scraped ${tracks.length} tracks from SoundCloud page for ${username}`);
      return tracks;
      
    } catch (error) {
      logger.error(`Web scraping failed for SoundCloud user ${username}`, error as Error);
      return [];
    }
  }
  
  /**
   * Fetch page content using Axios
   */
  private async fetchPageWithAxios(url: string): Promise<cheerio.CheerioAPI> {
    const response = await axios.get(url, {
      headers: {
        'User-Agent': this.userAgent,
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
        'Accept-Language': 'en-US,en;q=0.5',
        'Accept-Encoding': 'gzip, deflate',
        'DNT': '1',
        'Connection': 'keep-alive',
        'Upgrade-Insecure-Requests': '1',
      },
      timeout: 15000,
    });
    
    return cheerio.load(response.data);
  }
  
  /**
   * Fetch page content using browser automation (fallback)
   */
  private async fetchPageWithBrowser(url: string): Promise<cheerio.CheerioAPI> {
    const { chromium } = await import('playwright');
    let browser = null;
    let page = null;
    
    try {
      browser = await chromium.launch({
        headless: true,
        args: ['--no-sandbox', '--disable-setuid-sandbox'],
      });
      
      page = await browser.newPage({
        userAgent: this.userAgent,
      });
      
      await page.goto(url, { waitUntil: 'networkidle', timeout: 30000 });
      
      // Wait for tracks to load
      await page.waitForTimeout(3000);
      
      // Scroll to load more tracks
      await page.evaluate(() => {
        for (let i = 0; i < 3; i++) {
          window.scrollBy(0, window.innerHeight);
        }
      });
      
      await page.waitForTimeout(2000);
      
      const content = await page.content();
      return cheerio.load(content);
      
    } finally {
      if (page) await page.close();
      if (browser) await browser.close();
    }
  }
  
  /**
   * Extract tracks from HTML content
   */
  private async extractTracksFromHTML($: cheerio.CheerioAPI, username: string, limit: number): Promise<RawMix[]> {
    const tracks: RawMix[] = [];
    
    // Try multiple selectors for different SoundCloud layouts
    const selectors = [
      'article[role="article"]', // New layout
      '.sound__body',           // Old layout
      '.trackItem',             // Alternative layout
      '[data-sc-track]'         // Data attribute selector
    ];
    
    for (const selector of selectors) {
      const elements = $(selector).toArray();
      
      for (const element of elements) {
        if (tracks.length >= limit) break;
        
        const $el = $(element);
        const trackData = await this.extractTrackFromElement($el, username);
        
        if (trackData) {
          tracks.push(trackData);
        }
      }
      
      // If we found tracks with this selector, stop trying others
      if (tracks.length > 0) break;
    }
    
    return tracks;
  }
  
  /**
   * Extract track data from a single HTML element
   */
  private async extractTrackFromElement($el: cheerio.Cheerio<cheerio.Element>, username: string): Promise<RawMix | null> {
    try {
      // Try multiple approaches to extract track data
      let title = '';
      let permalink = '';
      let uploadedAt: string | null = null;
      let artworkUrl: string | null = null;
      let duration: number | null = null;
      
      // Extract title - try multiple selectors
      const titleSelectors = [
        '.soundTitle__title',
        '.sc-link-primary',
        'h3 a',
        '[itemprop="name"]',
        '.trackItem__trackTitle'
      ];
      
      for (const selector of titleSelectors) {
        const titleEl = $el.find(selector).first();
        if (titleEl.length > 0) {
          title = titleEl.text().trim();
          if (title) break;
        }
      }
      
      // Extract permalink - try multiple approaches
      const linkSelectors = [
        '.soundTitle__title',
        '.sc-link-primary', 
        'h3 a',
        '.trackItem__trackTitle a'
      ];
      
      for (const selector of linkSelectors) {
        const linkEl = $el.find(selector).first();
        const href = linkEl.attr('href');
        if (href) {
          permalink = href;
          break;
        }
      }
      
      // Extract upload date
      const dateSelectors = [
        'time',
        '.sc-ministats-item time',
        '.trackItem__created time'
      ];
      
      for (const selector of dateSelectors) {
        const dateEl = $el.find(selector).first();
        const datetime = dateEl.attr('datetime') || dateEl.attr('title');
        if (datetime) {
          uploadedAt = new Date(datetime).toISOString();
          break;
        }
      }
      
      // Extract artwork
      const artworkSelectors = [
        '.sound__coverArt img',
        '.sc-artwork img',
        '.trackItem__artwork img'
      ];
      
      for (const selector of artworkSelectors) {
        const imgEl = $el.find(selector).first();
        const src = imgEl.attr('src');
        if (src) {
          artworkUrl = src;
          break;
        }
      }
      
      // Extract duration
      const durationSelectors = [
        '.sc-ministats-item:contains(":")' ,
        '.trackItem__duration'
      ];
      
      for (const selector of durationSelectors) {
        const durationEl = $el.find(selector).first();
        const durationText = durationEl.text().trim();
        if (durationText.includes(':')) {
          duration = this.parseDurationToSeconds(durationText);
          break;
        }
      }
      
      if (!title || !permalink) {
        return null;
      }
      
      const fullUrl = permalink.startsWith('http') ? permalink : `https://soundcloud.com${permalink}`;
      
      // Use new context rules engine for Phase 2 detection (limited for web scraping)
      const mixContent: MixContent = {
        title: title,
        description: '', // No description available from web scraping
        artist_name: username,
        platform: 'soundcloud',
        channel_name: username,
        channel_id: null // Not available from web scraping
      };
      
      const contextSuggestions = await this.contextRulesEngine.suggestContexts(
        mixContent,
        undefined, // artistId - will be populated after artist is approved
        'soundcloud'
      );
      
      return {
        id: '', // Will be generated
        provider: 'soundcloud',
        source_url: fullUrl,
        external_id: this.extractTrackIdFromUrl(fullUrl),
        raw_title: title,
        raw_description: null, // Would need separate request to get description
        raw_artist: username,
        uploaded_at: uploadedAt,
        duration_seconds: duration,
        artwork_url: artworkUrl,
        raw_metadata: {
          username,
          scraped: true,
          scrape_timestamp: new Date().toISOString()
        },
        status: 'pending',
        canonicalized_mix_id: null,
        error_message: null,
        created_at: new Date().toISOString(),
        processed_at: null,
        // Add Phase 2 context suggestions to raw_mix for moderator review
        suggested_contexts: contextSuggestions,
      };
      
    } catch (error) {
      logger.debug(`Failed to extract track from element: ${error}`);
      return null;
    }
  }
  
  /**
   * Parse duration string (e.g., "3:45") to seconds
   */
  private parseDurationToSeconds(durationStr: string): number | null {
    const match = durationStr.match(/(\d+):(\d{2})/);
    if (!match) return null;
    
    const minutes = parseInt(match[1]);
    const seconds = parseInt(match[2]);
    
    return minutes * 60 + seconds;
  }
  
  /**
   * Check if a track is a valid mix based on duration and date filters
   */
  private isValidMix(track: any, dateRange?: { from?: Date; to?: Date }): boolean {
    // Filter by duration (mixes are typically longer than 10 minutes)
    if (track.duration && track.duration < 10 * 60 * 1000) {
      return false;
    }
    
    // Filter by date range if specified
    if (dateRange) {
      const createdAt = new Date(track.created_at);
      if (dateRange.from && createdAt < dateRange.from) return false;
      if (dateRange.to && createdAt > dateRange.to) return false;
    }
    
    return true;
  }
  
  /**
   * Map SoundCloud API track data to RawMix
   */
  private async mapAPITrackToRawMix(track: any): Promise<RawMix> {
    // Use new context rules engine for Phase 2 detection
    const mixContent: MixContent = {
      title: track.title || '',
      description: track.description || '',
      artist_name: track.user?.display_name || track.user?.username || null,
      platform: 'soundcloud',
      channel_name: track.user?.display_name || track.user?.username || null,
      channel_id: track.user?.id?.toString() || null
    };
    
    const contextSuggestions = await this.contextRulesEngine.suggestContexts(
      mixContent,
      undefined, // artistId - will be populated after artist is approved
      'soundcloud'
    );
    
    return {
      id: '', // Will be generated
      provider: 'soundcloud',
      source_url: track.permalink_url,
      external_id: createExternalId('soundcloud', track.id.toString()),
      raw_title: track.title,
      raw_description: track.description,
      raw_artist: track.user?.username || null,
      uploaded_at: track.created_at ? new Date(track.created_at).toISOString() : null,
      duration_seconds: track.duration ? Math.floor(track.duration / 1000) : null,
      artwork_url: track.artwork_url,
      raw_metadata: {
        id: track.id,
        genre: track.genre,
        tag_list: track.tag_list,
        playback_count: track.playback_count,
        favoritings_count: track.favoritings_count,
        user: {
          id: track.user?.id,
          username: track.user?.username,
          display_name: track.user?.display_name,
        },
      },
      status: 'pending',
      canonicalized_mix_id: null,
      error_message: null,
      created_at: new Date().toISOString(),
      processed_at: null,
      // Add Phase 2 context suggestions to raw_mix for moderator review
      suggested_contexts: contextSuggestions,
    };
  }
  
  /**
   * Extract track ID from SoundCloud URL
   */
  private extractTrackIdFromUrl(url: string): string | null {
    // For web-scraped URLs, we won't have the numeric ID
    // Use the permalink as external ID instead
    const match = url.match(/soundcloud\.com\/([^\/]+)\/([^\/\?]+)/);
    return match ? `${match[1]}/${match[2]}` : null;
  }
  
  /**
   * Check if a line looks like a track listing
   */
  private isTrackLine(line: string): boolean {
    // Common patterns for track listings:
    // - Contains "- " (artist - title)
    // - Contains timestamp (00:00, [00:00], 1:23:45)
    // - Starts with number (1. , 01. , etc.)
    
    const patterns = [
      /^\d+[\.\)]\s+/, // Starts with number
      /\d{1,2}:\d{2}/, // Contains timestamp
      /\s-\s/, // Contains dash separator
      /^\[\d+:\d+\]/, // Starts with timestamp in brackets
    ];
    
    return patterns.some(pattern => pattern.test(line)) && line.length > 10;
  }
  
  /**
   * Parse a track line to extract artist, title, and timestamp
   */
  private parseTrackLine(line: string, position: number): {
    artist?: string;
    title?: string;
    timestamp?: number;
  } | null {
    // Remove leading numbers and dots
    let cleanLine = line.replace(/^\d+[\.\)]\s*/, '');
    
    // Extract timestamp
    const timestampMatch = cleanLine.match(/(\[?(\d{1,2}):(\d{2})(?::(\d{2}))?\]?)/);
    let timestamp: number | undefined;
    
    if (timestampMatch) {
      const hours = timestampMatch[4] ? parseInt(timestampMatch[2]) : 0;
      const minutes = timestampMatch[4] ? parseInt(timestampMatch[3]) : parseInt(timestampMatch[2]);
      const seconds = timestampMatch[4] ? parseInt(timestampMatch[4]) : parseInt(timestampMatch[3]);
      
      timestamp = hours * 3600 + minutes * 60 + seconds;
      
      // Remove timestamp from line
      cleanLine = cleanLine.replace(timestampMatch[1], '').trim();
    }
    
    // Try to split artist and title by " - "
    const dashSplit = cleanLine.split(' - ');
    if (dashSplit.length >= 2) {
      return {
        artist: dashSplit[0].trim(),
        title: dashSplit.slice(1).join(' - ').trim(),
        timestamp,
      };
    }
    
    // If no clear artist/title split, treat the whole line as title
    return {
      title: cleanLine.trim(),
      timestamp,
    };
  }
}