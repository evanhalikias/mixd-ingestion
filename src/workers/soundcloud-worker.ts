import axios from 'axios';
import * as cheerio from 'cheerio';
import { BaseIngestionWorker, type SourceConfig, type WorkerType } from '../lib/worker-interface';
import type { RawMix, RawTrack } from '../lib/supabase/types';
import { createExternalId } from '../lib/external-ids';
import { logger } from '../services/logger';

/**
 * SoundCloud ingestion worker
 * Fetches mixes from SoundCloud artists/labels and parses tracklists from descriptions
 */
export class SoundCloudWorker extends BaseIngestionWorker {
  readonly workerType: WorkerType = 'soundcloud';
  readonly name = 'SoundCloud Worker';
  
  private clientId?: string;
  private userAgent = 'mixd-ingestion/1.0';
  
  constructor() {
    super();
    this.clientId = process.env.SOUNDCLOUD_CLIENT_ID;
    
    if (!this.clientId) {
      logger.warn('SOUNDCLOUD_CLIENT_ID not set, will attempt to extract from web player');
    }
  }
  
  /**
   * Fetch new mixes from SoundCloud artists/labels
   */
  async fetchNewMixes(config: SourceConfig): Promise<RawMix[]> {
    const { artists = [], labels = [], maxResults = 50, dateRange } = config;
    const allSources = [...artists, ...labels];
    
    if (allSources.length === 0) {
      logger.warn('No SoundCloud artists or labels configured');
      return [];
    }
    
    const rawMixes: RawMix[] = [];
    
    for (const source of allSources) {
      try {
        logger.info(`Fetching tracks from SoundCloud user: ${source}`);
        const tracks = await this.fetchUserTracks(source, maxResults, dateRange);
        rawMixes.push(...tracks);
      } catch (err) {
        logger.error(`Failed to fetch tracks from ${source}`, err as Error, {
          workerType: this.workerType,
        });
      }
    }
    
    return rawMixes;
  }
  
  /**
   * Parse tracklist from SoundCloud description
   */
  async parseTracklist(rawMix: RawMix): Promise<RawTrack[] | null> {
    if (!rawMix.raw_description) {
      return null;
    }
    
    logger.debug(`Parsing tracklist for: ${rawMix.raw_title}`);
    
    const tracks: RawTrack[] = [];
    const lines = rawMix.raw_description.split('\n');
    let position = 1;
    
    for (const line of lines) {
      const trimmedLine = line.trim();
      if (this.isTrackLine(trimmedLine)) {
        const parsedTrack = this.parseTrackLine(trimmedLine, position);
        if (parsedTrack) {
          tracks.push({
            id: '', // Will be generated by database
            raw_mix_id: rawMix.id,
            line_text: trimmedLine,
            position,
            timestamp_seconds: parsedTrack.timestamp ?? null,
            raw_artist: parsedTrack.artist ?? null,
            raw_title: parsedTrack.title ?? null,
            source: 'description',
            created_at: new Date().toISOString(),
          });
          position++;
        }
      }
    }
    
    logger.info(`Parsed ${tracks.length} tracks from SoundCloud description`);
    return tracks.length > 0 ? tracks : null;
  }
  
  /**
   * Fetch tracks from a SoundCloud user
   */
  private async fetchUserTracks(
    username: string,
    limit: number,
    dateRange?: { from?: Date; to?: Date }
  ): Promise<RawMix[]> {
    try {
      // Try API approach first if we have client ID
      if (this.clientId) {
        return await this.fetchViaAPI(username, limit, dateRange);
      }
      
      // Fallback to web scraping
      return await this.fetchViaWebScraping(username, limit, dateRange);
    } catch (err) {
      logger.error(`Failed to fetch user tracks for ${username}`, err as Error);
      return [];
    }
  }
  
  /**
   * Fetch tracks via SoundCloud API (if client ID available)
   */
  private async fetchViaAPI(
    username: string,
    limit: number,
    dateRange?: { from?: Date; to?: Date }
  ): Promise<RawMix[]> {
    // First resolve username to user ID
    const userResponse = await axios.get(`https://api.soundcloud.com/resolve`, {
      params: {
        url: `https://soundcloud.com/${username}`,
        client_id: this.clientId,
      },
      headers: {
        'User-Agent': this.userAgent,
      },
    });
    
    const userId = userResponse.data.id;
    
    // Fetch user's tracks
    const tracksResponse = await axios.get(`https://api.soundcloud.com/users/${userId}/tracks`, {
      params: {
        client_id: this.clientId,
        limit,
        linked_partitioning: 1,
      },
      headers: {
        'User-Agent': this.userAgent,
      },
    });
    
    const tracks = tracksResponse.data.collection || [];
    
    return tracks
      .filter((track: any) => this.isValidMix(track, dateRange))
      .map((track: any) => this.mapAPITrackToRawMix(track));
  }
  
  /**
   * Fetch tracks via web scraping (fallback method)
   */
  private async fetchViaWebScraping(
    username: string,
    limit: number,
    dateRange?: { from?: Date; to?: Date }
  ): Promise<RawMix[]> {
    const url = `https://soundcloud.com/${username}/tracks`;
    
    const response = await axios.get(url, {
      headers: {
        'User-Agent': this.userAgent,
      },
    });
    
    const $ = cheerio.load(response.data);
    
    // Extract tracks from the page
    // This is a simplified implementation - SoundCloud's actual structure is more complex
    const tracks: RawMix[] = [];
    
    $('.sound__body').each((index, element) => {
      if (tracks.length >= limit) return false;
      
      const $sound = $(element);
      const title = $sound.find('.soundTitle__title').text().trim();
      const permalink = $sound.find('.sound__coverArt').attr('href');
      
      if (title && permalink) {
        const fullUrl = `https://soundcloud.com${permalink}`;
        
        tracks.push({
          id: '', // Will be generated
          provider: 'soundcloud',
          source_url: fullUrl,
          external_id: this.extractTrackIdFromUrl(fullUrl),
          raw_title: title,
          raw_description: null, // Would need separate request to get description
          raw_artist: username,
          uploaded_at: null, // Would need to parse from page
          duration_seconds: null,
          artwork_url: null,
          raw_metadata: {
            username,
            scraped: true,
          },
          status: 'pending',
          canonicalized_mix_id: null,
          error_message: null,
          created_at: new Date().toISOString(),
          processed_at: null,
        });
      }
    });
    
    logger.info(`Scraped ${tracks.length} tracks from SoundCloud page`);
    return tracks;
  }
  
  /**
   * Check if a track is a valid mix based on duration and date filters
   */
  private isValidMix(track: any, dateRange?: { from?: Date; to?: Date }): boolean {
    // Filter by duration (mixes are typically longer than 10 minutes)
    if (track.duration && track.duration < 10 * 60 * 1000) {
      return false;
    }
    
    // Filter by date range if specified
    if (dateRange) {
      const createdAt = new Date(track.created_at);
      if (dateRange.from && createdAt < dateRange.from) return false;
      if (dateRange.to && createdAt > dateRange.to) return false;
    }
    
    return true;
  }
  
  /**
   * Map SoundCloud API track data to RawMix
   */
  private mapAPITrackToRawMix(track: any): RawMix {
    return {
      id: '', // Will be generated
      provider: 'soundcloud',
      source_url: track.permalink_url,
      external_id: createExternalId('soundcloud', track.id.toString()),
      raw_title: track.title,
      raw_description: track.description,
      raw_artist: track.user?.username || null,
      uploaded_at: track.created_at ? new Date(track.created_at).toISOString() : null,
      duration_seconds: track.duration ? Math.floor(track.duration / 1000) : null,
      artwork_url: track.artwork_url,
      raw_metadata: {
        id: track.id,
        genre: track.genre,
        tag_list: track.tag_list,
        playback_count: track.playback_count,
        favoritings_count: track.favoritings_count,
        user: {
          id: track.user?.id,
          username: track.user?.username,
          display_name: track.user?.display_name,
        },
      },
      status: 'pending',
      canonicalized_mix_id: null,
      error_message: null,
      created_at: new Date().toISOString(),
      processed_at: null,
    };
  }
  
  /**
   * Extract track ID from SoundCloud URL
   */
  private extractTrackIdFromUrl(url: string): string | null {
    // For web-scraped URLs, we won't have the numeric ID
    // Use the permalink as external ID instead
    const match = url.match(/soundcloud\.com\/([^\/]+)\/([^\/\?]+)/);
    return match ? `${match[1]}/${match[2]}` : null;
  }
  
  /**
   * Check if a line looks like a track listing
   */
  private isTrackLine(line: string): boolean {
    // Common patterns for track listings:
    // - Contains "- " (artist - title)
    // - Contains timestamp (00:00, [00:00], 1:23:45)
    // - Starts with number (1. , 01. , etc.)
    
    const patterns = [
      /^\d+[\.\)]\s+/, // Starts with number
      /\d{1,2}:\d{2}/, // Contains timestamp
      /\s-\s/, // Contains dash separator
      /^\[\d+:\d+\]/, // Starts with timestamp in brackets
    ];
    
    return patterns.some(pattern => pattern.test(line)) && line.length > 10;
  }
  
  /**
   * Parse a track line to extract artist, title, and timestamp
   */
  private parseTrackLine(line: string, position: number): {
    artist?: string;
    title?: string;
    timestamp?: number;
  } | null {
    // Remove leading numbers and dots
    let cleanLine = line.replace(/^\d+[\.\)]\s*/, '');
    
    // Extract timestamp
    const timestampMatch = cleanLine.match(/(\[?(\d{1,2}):(\d{2})(?::(\d{2}))?\]?)/);
    let timestamp: number | undefined;
    
    if (timestampMatch) {
      const hours = timestampMatch[4] ? parseInt(timestampMatch[2]) : 0;
      const minutes = timestampMatch[4] ? parseInt(timestampMatch[3]) : parseInt(timestampMatch[2]);
      const seconds = timestampMatch[4] ? parseInt(timestampMatch[4]) : parseInt(timestampMatch[3]);
      
      timestamp = hours * 3600 + minutes * 60 + seconds;
      
      // Remove timestamp from line
      cleanLine = cleanLine.replace(timestampMatch[1], '').trim();
    }
    
    // Try to split artist and title by " - "
    const dashSplit = cleanLine.split(' - ');
    if (dashSplit.length >= 2) {
      return {
        artist: dashSplit[0].trim(),
        title: dashSplit.slice(1).join(' - ').trim(),
        timestamp,
      };
    }
    
    // If no clear artist/title split, treat the whole line as title
    return {
      title: cleanLine.trim(),
      timestamp,
    };
  }
}