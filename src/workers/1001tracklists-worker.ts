import axios from 'axios';
import * as cheerio from 'cheerio';
import { chromium, type Browser, type Page } from 'playwright';
import * as readline from 'readline';
import { BaseIngestionWorker, type SourceConfig, type WorkerType } from '../lib/worker-interface';
import type { RawMix, RawTrack } from '../lib/supabase/types';
import { createExternalId } from '../lib/external-ids';
import { logger } from '../services/logger';

/**
 * Enhanced 1001Tracklists ingestion worker
 * Scrapes tracklists from 1001tracklists.com using advanced Playwright automation
 * with sophisticated track parsing, metadata extraction, and captcha handling
 */
export class OneTracklistWorker extends BaseIngestionWorker {
  readonly workerType: WorkerType = '1001tracklists';
  readonly name = '1001Tracklists Worker';
  
  private userAgent = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36';
  private baseUrl = 'https://www.1001tracklists.com';
  private requestDelay = 2000; // 2 second delay between requests to be respectful
  private interactiveMode = false; // Set to true for manual captcha solving
  
  /**
   * Fetch new mixes from 1001Tracklists
   */
  async fetchNewMixes(config: SourceConfig): Promise<RawMix[]> {
    const { searchTerms = [], urls = [], maxResults = 50, dateRange } = config;
    
    if (searchTerms.length === 0 && urls.length === 0) {
      logger.warn('No 1001Tracklists search terms or URLs configured');
      return [];
    }
    
    const rawMixes: RawMix[] = [];
    
    // Process direct URLs
    for (const url of urls) {
      try {
        logger.info(`Fetching tracklist from URL: ${url}`);
        const mix = await this.fetchTracklistFromUrl(url);
        if (mix) rawMixes.push(mix);
        
        await this.delay(this.requestDelay);
      } catch (err) {
        logger.error(`Failed to fetch tracklist from URL ${url}`, err as Error, {
          workerType: this.workerType,
        });
      }
    }
    
    // Process search terms
    for (const searchTerm of searchTerms) {
      try {
        logger.info(`Searching 1001Tracklists for: ${searchTerm}`);
        const searchResults = await this.searchTracklists(searchTerm, maxResults, dateRange);
        rawMixes.push(...searchResults);
        
        await this.delay(this.requestDelay);
      } catch (err) {
        logger.error(`Failed to search for ${searchTerm}`, err as Error, {
          workerType: this.workerType,
        });
      }
    }
    
    return rawMixes;
  }
  
  /**
   * Parse tracklist - Enhanced to handle sophisticated track data
   */
  async parseTracklist(rawMix: RawMix): Promise<RawTrack[] | null> {
    // For 1001Tracklists, we fetch the full tracklist during the initial scraping
    // So we can parse it from the stored metadata
    const metadata = rawMix.raw_metadata as any;
    
    if (!metadata?.tracklist || !Array.isArray(metadata.tracklist)) {
      logger.warn(`No tracklist data found in metadata for mix: ${rawMix.raw_title}`);
      return null;
    }
    
    const tracks: RawTrack[] = metadata.tracklist.map((track: any, index: number) => ({
      id: '', // Will be generated by database
      raw_mix_id: rawMix.id,
      line_text: this.formatEnhancedTrackLine(track),
      position: typeof track.order === 'number' ? track.order : index + 1,
      timestamp_seconds: this.parseSetTimeToSeconds(track.set_time),
      raw_artist: track.artist !== 'Unknown Artist' ? track.artist : null,
      raw_title: track.working_title || track.title !== 'Unknown Title' ? (track.working_title || track.title) : null,
      source: '1001tracklists',
      created_at: new Date().toISOString(),
    }));
    
    logger.info(`Parsed ${tracks.length} tracks from 1001Tracklists with enhanced metadata`);
    return tracks;
  }
  
  /**
   * Search for tracklists on 1001Tracklists
   */
  private async searchTracklists(
    searchTerm: string,
    maxResults: number,
    dateRange?: { from?: Date; to?: Date }
  ): Promise<RawMix[]> {
    const searchUrl = `${this.baseUrl}/search/tracklist`;
    const searchParams = new URLSearchParams({
      query: searchTerm,
      sortBy: 'date',
    });
    
    try {
      // First try with regular HTTP request
      const response = await axios.get(`${searchUrl}?${searchParams}`, {
        headers: {
          'User-Agent': this.userAgent,
          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
          'Accept-Language': 'en-US,en;q=0.5',
          'Accept-Encoding': 'gzip, deflate',
          'DNT': '1',
          'Connection': 'keep-alive',
          'Upgrade-Insecure-Requests': '1',
        },
        timeout: 30000,
      });
      
      return this.parseSearchResults(response.data, maxResults, dateRange);
    } catch (err) {
      logger.warn(`HTTP request failed for search: ${searchTerm}, trying headless browser`);
      
      // Fallback to headless browser
      return await this.searchWithBrowser(searchTerm, maxResults, dateRange);
    }
  }
  
  /**
   * Search using headless browser (fallback method)
   */
  private async searchWithBrowser(
    searchTerm: string,
    maxResults: number,
    dateRange?: { from?: Date; to?: Date }
  ): Promise<RawMix[]> {
    let browser: Browser | null = null;
    let page: Page | null = null;
    
    try {
      browser = await chromium.launch({
        headless: true,
        args: ['--no-sandbox', '--disable-setuid-sandbox'],
      });
      
      page = await browser.newPage({
        userAgent: this.userAgent,
      });
      
      // Navigate to search page
      const searchUrl = `${this.baseUrl}/search/tracklist?query=${encodeURIComponent(searchTerm)}&sortBy=date`;
      await page.goto(searchUrl, { waitUntil: 'networkidle' });
      
      // Wait for search results to load
      await page.waitForSelector('.tracklist-item, .no-results', { timeout: 10000 });
      
      // Get page content
      const content = await page.content();
      
      return this.parseSearchResults(content, maxResults, dateRange);
    } catch (err) {
      logger.error(`Browser search failed for: ${searchTerm}`, err as Error);
      return [];
    } finally {
      if (page) await page.close();
      if (browser) await browser.close();
    }
  }
  
  /**
   * Parse search results HTML
   */
  private parseSearchResults(
    html: string,
    maxResults: number,
    dateRange?: { from?: Date; to?: Date }
  ): RawMix[] {
    const $ = cheerio.load(html);
    const results: RawMix[] = [];
    
    $('.tracklist-item, .tlListItem').each((index, element) => {
      if (results.length >= maxResults) return false;
      
      const $item = $(element);
      const titleLink = $item.find('.tlListItemTitle a, .tracklist-title a').first();
      const title = titleLink.text().trim();
      const relativeUrl = titleLink.attr('href');
      
      if (!title || !relativeUrl) return;
      
      const fullUrl = relativeUrl.startsWith('http') ? relativeUrl : `${this.baseUrl}${relativeUrl}`;
      const mixId = this.extractMixIdFromUrl(fullUrl);
      
      if (!mixId) return;
      
      // Extract additional metadata
      const artist = $item.find('.tlListItemArtist, .tracklist-artist').text().trim();
      const date = $item.find('.tlListItemDate, .tracklist-date').text().trim();
      
      // Check date filter
      if (dateRange && date) {
        const mixDate = this.parseDate(date);
        if (mixDate) {
          if (dateRange.from && mixDate < dateRange.from) return;
          if (dateRange.to && mixDate > dateRange.to) return;
        }
      }
      
      results.push({
        id: '', // Will be generated
        provider: '1001tracklists',
        source_url: fullUrl,
        external_id: createExternalId('1001tracklists', mixId),
        raw_title: title,
        raw_description: null, // Will be fetched when parsing full tracklist
        raw_artist: artist || null,
        uploaded_at: date ? this.parseDate(date)?.toISOString() || null : null,
        duration_seconds: null,
        artwork_url: null,
        raw_metadata: {
          mixId,
          searchResult: true,
        },
        status: 'pending',
        canonicalized_mix_id: null,
        error_message: null,
        created_at: new Date().toISOString(),
        processed_at: null,
      });
    });
    
    return results;
  }
  
  /**
   * Fetch full tracklist from a 1001Tracklists URL using advanced Playwright scraping
   */
  private async fetchTracklistFromUrl(url: string): Promise<RawMix | null> {
    if (!url || !url.includes('1001tracklists.com')) {
      logger.error('Invalid 1001Tracklists URL provided');
      return null;
    }

    return await this.fetchTracklistWithBrowser(url);
  }
  
  /**
   * Fetch tracklist using advanced Playwright browser automation
   */
  private async fetchTracklistWithBrowser(url: string): Promise<RawMix | null> {
    let browser: Browser | null = null;
    let page: Page | null = null;
    
    try {
      logger.info(`🌐 Launching browser for URL: ${url}`);
      
      browser = await chromium.launch({
        headless: !this.interactiveMode, // Allow interactive mode for captcha solving
        args: ['--no-sandbox', '--disable-setuid-sandbox'],
      });
      
      const context = await browser.newContext({
        userAgent: this.userAgent,
      });
      
      page = await context.newPage();
      
      logger.info('🌐 Navigating to mix URL...');
      await page.goto(url, { waitUntil: 'domcontentloaded', timeout: 45000 });
      
      // Handle captcha if in interactive mode
      if (this.interactiveMode) {
        await this.handleCaptcha();
      }
      
      // Wait for page to finish loading
      await page.waitForTimeout(10000);
      
      // Extract all data using sophisticated parsing
      // @ts-ignore - This code runs in browser context and has access to DOM
      const mixData = await page.evaluate(() => {
        // Extract title and date from the page title
        let fullTitle = '';
        let date = '';
        const pageTitleEl = document.querySelector('#pageTitle h1') as HTMLElement;
        if (pageTitleEl) {
          fullTitle = pageTitleEl.innerText.trim();
          // Try to extract date at the end (YYYY-MM-DD)
          const dateMatch = fullTitle.match(/(\d{4}-\d{2}-\d{2})$/);
          if (dateMatch) {
            date = dateMatch[1];
            fullTitle = fullTitle.replace(/\s*\d{4}-\d{2}-\d{2}$/, '').trim();
          }
        } else {
          fullTitle = 'Unknown Title';
        }

        const soundcloudLink = Array.from(document.querySelectorAll('a')).find((a: any) =>
          a.href && a.href.includes('soundcloud.com')
        )?.href || null;
        
        // Extract cover_url from the og:image meta tag
        const coverUrl = (document.querySelector('meta[property="og:image"]') as HTMLMetaElement)?.content || null;
        
        // Extract mix_artist from the author meta tag within the MusicPlaylist schema
        const mixArtist = (document.querySelector('div[itemtype="http://schema.org/MusicPlaylist"] meta[itemprop="author"]') as HTMLMetaElement)?.content || null;
        
        // Extract audio_url from SoundCloud iframe widget
        let audioUrl = null;
        const iframe = document.querySelector('iframe[src*="soundcloud.com/player"]') as HTMLIFrameElement;
        if (iframe) {
          const fullUrl = iframe.src;
          // Extract just the base URL with track ID, removing extra parameters
          const match = fullUrl.match(/^(https:\/\/w\.soundcloud\.com\/player\/\?url=https:\/\/api\.soundcloud\.com\/tracks\/\d+)/);
          if (match) {
            audioUrl = match[1];
          }
        }

        const trackRows = Array.from(document.querySelectorAll('div[id^="tlp_"].tlpTog.tlpItem'));
        let unknownTrackCounter = 0;
        const tracklist = trackRows.map((row: any, idx: number) => {
          const trackNumber = (row.querySelector('.fontXL') as HTMLElement)?.innerText.trim() || (idx + 1);
          let setTime = (row.querySelector('div.cue[data-mode="hours"]') as HTMLElement)?.innerText.trim() || '??:??';
          if (idx === 0 && setTime === '??:??') setTime = '00:00';
          let artist = (row.querySelector('meta[itemprop="byArtist"]') as HTMLMetaElement)?.content || 'Unknown Artist';
          let title = (row.querySelector('meta[itemprop="name"]') as HTMLMetaElement)?.content || 'Unknown Title';

          // Check for extra status (e.g., 'ID Remix') and append to title if present
          const statusEl = row.querySelector('.trackStatus') as HTMLElement;
          if (statusEl && statusEl.innerText.trim()) {
            const statusText = statusEl.innerText.trim();
            // Only append if not already present in the title
            if (!title.toLowerCase().includes(statusText.toLowerCase())) {
              title += (title.endsWith(' ') ? '' : ' ') + statusText;
            }
          }

          // Detect if played together with previous track
          let played_with_previous = false;
          const trackNumSpan = row.querySelector('.tracknumber_value') as HTMLElement;
          if (trackNumSpan && trackNumSpan.getAttribute('title') === 'played together with previous track') {
            played_with_previous = true;
          }

          // Helper function to escape regex special characters
          function escapeRegex(str: string): string {
            return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          }

          // Regex to match 'Artist ft. ...' or 'Artist feat. ...' at the start of the title
          const artistFtRegex = new RegExp(`^(${escapeRegex(artist)})\\s*(ft\\.|feat\\.)\\s+([^–—:]+)\\s*[-–—:]\\s*(.+)`, 'i');
          const match = title.match(artistFtRegex);
          if (match) {
            artist = `${match[1]} ft. ${match[3].trim()}`;
            title = match[4].trim();
          } else {
            const artistBase = artist.replace(/\s*\([A-Z]{2,3}\)$/, '').trim();
            const artistPattern = `^(${escapeRegex(artist)}|${escapeRegex(artistBase)})\\s*[-–—:]\\s*`;
            title = title.replace(new RegExp(artistPattern, 'i'), '').trim();
          }

          // Check for Spotify icon
          const spotifyIcon = row.querySelector('i.fa-spotify') as HTMLElement;
          const spotify_url_exists = spotifyIcon && spotifyIcon.classList.contains('colorized') ? 1 : 0;

          // Determine if the track is unreleased (ID-style)
          const isUnknown = artist === 'Unknown Artist' && title === 'Unknown Title';
          let working_title = '';
          if (isUnknown) {
            unknownTrackCounter++;
            working_title = `ID${unknownTrackCounter.toString().padStart(2, '0')}`;
          }
          const context = isUnknown ? fullTitle : '';

          return {
            order: trackNumber,
            set_time: setTime,
            artist,
            title,
            original_title: title,   // preserve the scraped raw title
            working_title,           // used for ID-style tracks
            context,                 // only populated for unreleased IDs
            spotify_url_exists,
            played_with_previous
          };
        });

        return {
          mix: {
            title: fullTitle,
            date,
            mix_artist: mixArtist,
            soundcloud_url: soundcloudLink,
            cover_url: coverUrl,
            audio_url: audioUrl,
            tracklist
          }
        };
      });
      
      if (!mixData) {
        logger.warn(`Could not extract mix data from URL: ${url}`);
        return null;
      }
      
      // Convert to RawMix format
      return this.convertToRawMix(mixData, url);
      
    } catch (err) {
      logger.error(`Browser fetch failed for URL: ${url}`, err as Error);
      return null;
    } finally {
      if (page) await page.close();
      if (browser) await browser.close();
    }
  }
  
  /**
   * Handle captcha solving in interactive mode
   */
  private async handleCaptcha(): Promise<void> {
    if (!this.interactiveMode) return;
    
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });
    
    return new Promise(resolve => {
      rl.question('🛑 Please solve the captcha in the browser, then press Enter here to continue...', () => {
        rl.close();
        resolve();
      });
    });
  }
  
  /**
   * Convert extracted mix data to RawMix format
   */
  private convertToRawMix(mixData: any, url: string): RawMix {
    const mixId = this.extractMixIdFromUrl(url);
    const mix = mixData.mix;
    
    return {
      id: '', // Will be generated by database
      provider: '1001tracklists',
      source_url: url,
      external_id: createExternalId('1001tracklists', mixId || ''),
      raw_title: mix.title || null,
      raw_description: null,
      raw_artist: mix.mix_artist || null,
      uploaded_at: mix.date ? new Date(mix.date).toISOString() : null,
      duration_seconds: null,
      artwork_url: mix.cover_url || null,
      raw_metadata: {
        mixId,
        ...mix,
        trackCount: mix.tracklist?.length || 0,
      },
      status: 'pending',
      canonicalized_mix_id: null,
      error_message: null,
      created_at: new Date().toISOString(),
      processed_at: null,
    };
  }
  

  /**
   * Extract mix ID from 1001Tracklists URL
   */
  private extractMixIdFromUrl(url: string): string | null {
    const match = url.match(/\/tracklist\/(\d+)/);
    return match ? match[1] : null;
  }
  
  /**
   * Parse date string from 1001Tracklists
   */
  private parseDate(dateStr: string): Date | null {
    try {
      // Common formats: "Dec 15, 2023", "15/12/2023", "2023-12-15"
      return new Date(dateStr);
    } catch {
      return null;
    }
  }
  
  /**
   * Parse timestamp string to seconds (enhanced version)
   */
  private parseTimestamp(timestamp: string): number | null {
    if (!timestamp || timestamp === '??:??') return null;
    
    const match = timestamp.match(/(\d{1,2}):(\d{2})(?::(\d{2}))?/);
    if (!match) return null;
    
    const hours = match[3] ? parseInt(match[1]) : 0;
    const minutes = match[3] ? parseInt(match[2]) : parseInt(match[1]);
    const seconds = match[3] ? parseInt(match[3]) : parseInt(match[2]);
    
    return hours * 3600 + minutes * 60 + seconds;
  }
  
  /**
   * Format enhanced track data into a readable line
   */
  private formatEnhancedTrackLine(track: any): string {
    const parts = [];
    
    // Add set time if available
    if (track.set_time && track.set_time !== '??:??') {
      parts.push(track.set_time);
    }
    
    // Determine track identifier
    let trackInfo = '';
    if (track.working_title) {
      // Use working title for ID tracks
      trackInfo = track.working_title;
      if (track.context) {
        trackInfo += ` (${track.context})`;
      }
    } else if (track.artist !== 'Unknown Artist' && track.title !== 'Unknown Title') {
      trackInfo = `${track.artist} - ${track.title}`;
    } else if (track.title !== 'Unknown Title') {
      trackInfo = track.title;
    }
    
    if (trackInfo) {
      parts.push(trackInfo);
    }
    
    // Add indicators
    const indicators = [];
    if (track.played_with_previous) {
      indicators.push('played together');
    }
    if (track.spotify_url_exists) {
      indicators.push('on Spotify');
    }
    
    if (indicators.length > 0) {
      parts.push(`[${indicators.join(', ')}]`);
    }
    
    return parts.join(' ');
  }
  
  /**
   * Convert set time string (HH:MM or MM:SS) to seconds
   */
  private parseSetTimeToSeconds(setTime: string): number | null {
    if (!setTime || setTime === '??:??' || setTime === '00:00') {
      return setTime === '00:00' ? 0 : null;
    }
    
    const match = setTime.match(/(\d{1,2}):(\d{2})/);
    if (!match) return null;
    
    const minutes = parseInt(match[1]);
    const seconds = parseInt(match[2]);
    
    return minutes * 60 + seconds;
  }
  
  /**
   * Format seconds back to timestamp string (enhanced)
   */
  private formatTimestamp(seconds: number): string {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;
    
    if (hours > 0) {
      return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    } else {
      return `${minutes}:${secs.toString().padStart(2, '0')}`;
    }
  }
  
  /**
   * Set interactive mode for captcha handling
   */
  public setInteractiveMode(interactive: boolean): void {
    this.interactiveMode = interactive;
    logger.info(`Interactive mode ${interactive ? 'enabled' : 'disabled'} for captcha handling`);
  }
  
  /**
   * Add delay between requests to be respectful
   */
  private async delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}