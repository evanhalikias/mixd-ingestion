import axios from 'axios';
import * as cheerio from 'cheerio';
import { chromium, type Browser, type Page } from 'playwright';
import { BaseIngestionWorker, type SourceConfig, type WorkerType } from '../lib/worker-interface';
import type { RawMix, RawTrack } from '../lib/supabase/types';
import { createExternalId } from '../lib/external-ids';
import { logger } from '../services/logger';

/**
 * 1001Tracklists ingestion worker
 * Scrapes tracklists from 1001tracklists.com with headless browser fallback
 */
export class OneTracklistWorker extends BaseIngestionWorker {
  readonly workerType: WorkerType = '1001tracklists';
  readonly name = '1001Tracklists Worker';
  
  private userAgent = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36';
  private baseUrl = 'https://www.1001tracklists.com';
  private requestDelay = 2000; // 2 second delay between requests to be respectful
  
  /**
   * Fetch new mixes from 1001Tracklists
   */
  async fetchNewMixes(config: SourceConfig): Promise<RawMix[]> {
    const { searchTerms = [], urls = [], maxResults = 50, dateRange } = config;
    
    if (searchTerms.length === 0 && urls.length === 0) {
      logger.warn('No 1001Tracklists search terms or URLs configured');
      return [];
    }
    
    const rawMixes: RawMix[] = [];
    
    // Process direct URLs
    for (const url of urls) {
      try {
        logger.info(`Fetching tracklist from URL: ${url}`);
        const mix = await this.fetchTracklistFromUrl(url);
        if (mix) rawMixes.push(mix);
        
        await this.delay(this.requestDelay);
      } catch (err) {
        logger.error(`Failed to fetch tracklist from URL ${url}`, err as Error, {
          workerType: this.workerType,
        });
      }
    }
    
    // Process search terms
    for (const searchTerm of searchTerms) {
      try {
        logger.info(`Searching 1001Tracklists for: ${searchTerm}`);
        const searchResults = await this.searchTracklists(searchTerm, maxResults, dateRange);
        rawMixes.push(...searchResults);
        
        await this.delay(this.requestDelay);
      } catch (err) {
        logger.error(`Failed to search for ${searchTerm}`, err as Error, {
          workerType: this.workerType,
        });
      }
    }
    
    return rawMixes;
  }
  
  /**
   * Parse tracklist - 1001Tracklists provides structured tracklist data
   */
  async parseTracklist(rawMix: RawMix): Promise<RawTrack[] | null> {
    // For 1001Tracklists, we fetch the full tracklist during the initial scraping
    // So we can parse it from the stored metadata
    const metadata = rawMix.raw_metadata as any;
    
    if (!metadata?.tracks || !Array.isArray(metadata.tracks)) {
      logger.warn(`No track data found in metadata for mix: ${rawMix.raw_title}`);
      return null;
    }
    
    const tracks: RawTrack[] = metadata.tracks.map((track: any, index: number) => ({
      id: '', // Will be generated by database
      raw_mix_id: rawMix.id,
      line_text: this.formatTrackLine(track),
      position: index + 1,
      timestamp_seconds: track.timestamp || null,
      raw_artist: track.artist || null,
      raw_title: track.title || null,
      source: '1001tracklists',
      created_at: new Date().toISOString(),
    }));
    
    logger.info(`Parsed ${tracks.length} tracks from 1001Tracklists`);
    return tracks;
  }
  
  /**
   * Search for tracklists on 1001Tracklists
   */
  private async searchTracklists(
    searchTerm: string,
    maxResults: number,
    dateRange?: { from?: Date; to?: Date }
  ): Promise<RawMix[]> {
    const searchUrl = `${this.baseUrl}/search/tracklist`;
    const searchParams = new URLSearchParams({
      query: searchTerm,
      sortBy: 'date',
    });
    
    try {
      // First try with regular HTTP request
      const response = await axios.get(`${searchUrl}?${searchParams}`, {
        headers: {
          'User-Agent': this.userAgent,
          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
          'Accept-Language': 'en-US,en;q=0.5',
          'Accept-Encoding': 'gzip, deflate',
          'DNT': '1',
          'Connection': 'keep-alive',
          'Upgrade-Insecure-Requests': '1',
        },
        timeout: 30000,
      });
      
      return this.parseSearchResults(response.data, maxResults, dateRange);
    } catch (err) {
      logger.warn(`HTTP request failed for search: ${searchTerm}, trying headless browser`);
      
      // Fallback to headless browser
      return await this.searchWithBrowser(searchTerm, maxResults, dateRange);
    }
  }
  
  /**
   * Search using headless browser (fallback method)
   */
  private async searchWithBrowser(
    searchTerm: string,
    maxResults: number,
    dateRange?: { from?: Date; to?: Date }
  ): Promise<RawMix[]> {
    let browser: Browser | null = null;
    let page: Page | null = null;
    
    try {
      browser = await chromium.launch({
        headless: true,
        args: ['--no-sandbox', '--disable-setuid-sandbox'],
      });
      
      page = await browser.newPage({
        userAgent: this.userAgent,
      });
      
      // Navigate to search page
      const searchUrl = `${this.baseUrl}/search/tracklist?query=${encodeURIComponent(searchTerm)}&sortBy=date`;
      await page.goto(searchUrl, { waitUntil: 'networkidle' });
      
      // Wait for search results to load
      await page.waitForSelector('.tracklist-item, .no-results', { timeout: 10000 });
      
      // Get page content
      const content = await page.content();
      
      return this.parseSearchResults(content, maxResults, dateRange);
    } catch (err) {
      logger.error(`Browser search failed for: ${searchTerm}`, err as Error);
      return [];
    } finally {
      if (page) await page.close();
      if (browser) await browser.close();
    }
  }
  
  /**
   * Parse search results HTML
   */
  private parseSearchResults(
    html: string,
    maxResults: number,
    dateRange?: { from?: Date; to?: Date }
  ): RawMix[] {
    const $ = cheerio.load(html);
    const results: RawMix[] = [];
    
    $('.tracklist-item, .tlListItem').each((index, element) => {
      if (results.length >= maxResults) return false;
      
      const $item = $(element);
      const titleLink = $item.find('.tlListItemTitle a, .tracklist-title a').first();
      const title = titleLink.text().trim();
      const relativeUrl = titleLink.attr('href');
      
      if (!title || !relativeUrl) return;
      
      const fullUrl = relativeUrl.startsWith('http') ? relativeUrl : `${this.baseUrl}${relativeUrl}`;
      const mixId = this.extractMixIdFromUrl(fullUrl);
      
      if (!mixId) return;
      
      // Extract additional metadata
      const artist = $item.find('.tlListItemArtist, .tracklist-artist').text().trim();
      const date = $item.find('.tlListItemDate, .tracklist-date').text().trim();
      
      // Check date filter
      if (dateRange && date) {
        const mixDate = this.parseDate(date);
        if (mixDate) {
          if (dateRange.from && mixDate < dateRange.from) return;
          if (dateRange.to && mixDate > dateRange.to) return;
        }
      }
      
      results.push({
        id: '', // Will be generated
        provider: '1001tracklists',
        source_url: fullUrl,
        external_id: createExternalId('1001tracklists', mixId),
        raw_title: title,
        raw_description: null, // Will be fetched when parsing full tracklist
        raw_artist: artist || null,
        uploaded_at: date ? this.parseDate(date)?.toISOString() || null : null,
        duration_seconds: null,
        artwork_url: null,
        raw_metadata: {
          mixId,
          searchResult: true,
        },
        status: 'pending',
        canonicalized_mix_id: null,
        error_message: null,
        created_at: new Date().toISOString(),
        processed_at: null,
      });
    });
    
    return results;
  }
  
  /**
   * Fetch full tracklist from a 1001Tracklists URL
   */
  private async fetchTracklistFromUrl(url: string): Promise<RawMix | null> {
    try {
      // First try with HTTP request
      const response = await axios.get(url, {
        headers: {
          'User-Agent': this.userAgent,
        },
        timeout: 30000,
      });
      
      return this.parseTracklistPage(response.data, url);
    } catch (err) {
      logger.warn(`HTTP request failed for URL: ${url}, trying headless browser`);
      
      // Fallback to headless browser
      return await this.fetchTracklistWithBrowser(url);
    }
  }
  
  /**
   * Fetch tracklist using headless browser
   */
  private async fetchTracklistWithBrowser(url: string): Promise<RawMix | null> {
    let browser: Browser | null = null;
    let page: Page | null = null;
    
    try {
      browser = await chromium.launch({
        headless: true,
        args: ['--no-sandbox', '--disable-setuid-sandbox'],
      });
      
      page = await browser.newPage({
        userAgent: this.userAgent,
      });
      
      await page.goto(url, { waitUntil: 'networkidle' });
      
      // Wait for tracklist to load
      await page.waitForSelector('.tracklist, .tracklistContent', { timeout: 10000 });
      
      const content = await page.content();
      
      return this.parseTracklistPage(content, url);
    } catch (err) {
      logger.error(`Browser fetch failed for URL: ${url}`, err as Error);
      return null;
    } finally {
      if (page) await page.close();
      if (browser) await browser.close();
    }
  }
  
  /**
   * Parse a full tracklist page
   */
  private parseTracklistPage(html: string, url: string): RawMix | null {
    const $ = cheerio.load(html);
    
    const title = $('.pageTitle, .tracklistTitle, h1').first().text().trim();
    if (!title) {
      logger.warn(`Could not extract title from URL: ${url}`);
      return null;
    }
    
    const mixId = this.extractMixIdFromUrl(url);
    if (!mixId) {
      logger.warn(`Could not extract mix ID from URL: ${url}`);
      return null;
    }
    
    // Extract metadata
    const artist = $('.artistName, .tracklistArtist').text().trim();
    const date = $('.tracklistDate, .dateTime').text().trim();
    const description = $('.tracklistDescription, .description').text().trim();
    
    // Extract tracks
    const tracks: any[] = [];
    $('.trackRow, .track-item, .tlListItem').each((index, element) => {
      const $track = $(element);
      
      const trackArtist = $track.find('.trackArtist, .artist').text().trim();
      const trackTitle = $track.find('.trackTitle, .title').text().trim();
      const timestamp = $track.find('.timestamp, .time').text().trim();
      
      if (trackArtist || trackTitle) {
        tracks.push({
          artist: trackArtist || null,
          title: trackTitle || null,
          timestamp: this.parseTimestamp(timestamp),
          rawText: $track.text().trim(),
        });
      }
    });
    
    return {
      id: '', // Will be generated
      provider: '1001tracklists',
      source_url: url,
      external_id: createExternalId('1001tracklists', mixId),
      raw_title: title,
      raw_description: description || null,
      raw_artist: artist || null,
      uploaded_at: date ? this.parseDate(date)?.toISOString() || null : null,
      duration_seconds: null,
      artwork_url: null,
      raw_metadata: {
        mixId,
        tracks,
        trackCount: tracks.length,
      },
      status: 'pending',
      canonicalized_mix_id: null,
      error_message: null,
      created_at: new Date().toISOString(),
      processed_at: null,
    };
  }
  
  /**
   * Extract mix ID from 1001Tracklists URL
   */
  private extractMixIdFromUrl(url: string): string | null {
    const match = url.match(/\/tracklist\/(\d+)/);
    return match ? match[1] : null;
  }
  
  /**
   * Parse date string from 1001Tracklists
   */
  private parseDate(dateStr: string): Date | null {
    try {
      // Common formats: "Dec 15, 2023", "15/12/2023", "2023-12-15"
      return new Date(dateStr);
    } catch {
      return null;
    }
  }
  
  /**
   * Parse timestamp string to seconds
   */
  private parseTimestamp(timestamp: string): number | null {
    if (!timestamp) return null;
    
    const match = timestamp.match(/(\d{1,2}):(\d{2})(?::(\d{2}))?/);
    if (!match) return null;
    
    const hours = match[3] ? parseInt(match[1]) : 0;
    const minutes = match[3] ? parseInt(match[2]) : parseInt(match[1]);
    const seconds = match[3] ? parseInt(match[3]) : parseInt(match[2]);
    
    return hours * 3600 + minutes * 60 + seconds;
  }
  
  /**
   * Format track data into a readable line
   */
  private formatTrackLine(track: any): string {
    const parts = [];
    
    if (track.timestamp) {
      parts.push(this.formatTimestamp(track.timestamp));
    }
    
    if (track.artist && track.title) {
      parts.push(`${track.artist} - ${track.title}`);
    } else if (track.title) {
      parts.push(track.title);
    } else if (track.rawText) {
      parts.push(track.rawText);
    }
    
    return parts.join(' ');
  }
  
  /**
   * Format seconds back to timestamp string
   */
  private formatTimestamp(seconds: number): string {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;
    
    if (hours > 0) {
      return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    } else {
      return `${minutes}:${secs.toString().padStart(2, '0')}`;
    }
  }
  
  /**
   * Add delay between requests to be respectful
   */
  private async delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}